-- automatically generated by BNF Converter
module Main where


import IO ( stdin, hGetContents )
import System ( getArgs, getProgName )

import Cl.Lex
import Cl.Par
import Cl.Skel
import Cl.Print
import Cl.Abs
import Cl.Layout

import Cl.ErrM

type ParseFun a = [Token] -> Err a

myLLexer = resolveLayout True . myLexer

runFile :: (Print a, Show a) => ParseFun a -> FilePath -> IO ()
runFile p f = readFile f >>= run p

run :: (Print a, Show a) => ParseFun a -> String -> IO ()
run p s = case (p (myLLexer s)) of
           Bad s    -> do  putStrLn "\nParse Failed...\n"
                           putStrLn s
           Ok  tree -> do putStrLn "\nParse Successful!"
                          putStrLn $ "\n[Abstract Syntax]\n\n" ++ show tree
                          putStrLn $ "\n[Linearized tree]\n\n" ++ printTree tree


main :: IO ()
main = do args <- getArgs
          case args of
            []  -> hGetContents stdin >>= run pModule
            [f] -> runFile pModule f
            _   -> do progName <- getProgName
                      putStrLn $ progName ++ ": excess arguments."
