-- This Happy file was machine-generated by the BNF converter
{
module Cl.Par where
import Cl.Abs
import Cl.Lex
import Cl.ErrM
}

%name pModule Module
%name pClause Clause

%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '_' { PT _ (TS "_") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 '|' { PT _ (TS "|") }
 '=' { PT _ (TS "=") }
 '
-- Properties
' { PT _ (TS "\n-- Properties\n") }
 ',' { PT _ (TS ",") }
 '
' { PT _ (TS "\n") }
 'not' { PT _ (TS "not") }
 'where' { PT _ (TS "where") }

L_ident  { PT _ (TV $$) }
L_err    { _ }


%%

Ident   : L_ident  { Ident $1 }

Id :: { Id }
Id : Ident '_' Ident { Qname $1 $3 } 


Exp1 :: { Exp }
Exp1 : Id { Evar $1 } 
  | Id { Efun $1 }
  | Id { Econ $1 }
  | '(' Exp ')' { $2 }


Exp0 :: { Exp }
Exp0 : Exp Exp1 { Eapp $1 $2 } 
  | Exp1 { $1 }


Exp :: { Exp }
Exp : Exp0 { $1 } 


Pat :: { Pat }
Pat : Id { Pvar $1 } 
  | '(' Id ListPat ')' { Pcon $2 (reverse $3) }


Guard :: { Guard }
Guard : '|' ListExp { Guard $2 } 


Def :: { Def }
Def : Pat '=' Exp { Def $1 $3 } 


Local :: { Local }
Local : 'where' ListDef { Loc $2 } 


Clause :: { Clause }
Clause : Id ListPat ListGuard '=' Exp ListLocal { Cl $1 (reverse $2) (reverse $3) $5 (reverse $6) } 


Lit :: { Lit }
Lit : Exp '=' Exp { Lpos $1 $3 } 
  | 'not' '(' Exp '=' Exp ')' { Lneg $3 $5 }
  | Id { Linline $1 }
  | Id { Lninline $1 }


Pcl :: { Pcl }
Pcl : ListLit { PCl $1 } 


PropCl :: { PropCl }
PropCl : Id ListId ListPcl ListPcl { Property $1 $2 $3 $4 } 


Module :: { Module }
Module : ListClause '
-- Properties
' ListPropCl { Mod $1 $3 } 


ListClause :: { [Clause] }
ListClause : {- empty -} { [] } 
  | Clause { (:[]) $1 }
  | Clause '
' ListClause { (:) $1 $3 }


ListPropCl :: { [PropCl] }
ListPropCl : {- empty -} { [] } 
  | PropCl { (:[]) $1 }
  | PropCl '
' ListPropCl { (:) $1 $3 }


ListPat :: { [Pat] }
ListPat : {- empty -} { [] } 
  | ListPat Pat { flip (:) $1 $2 }


ListGuard :: { [Guard] }
ListGuard : {- empty -} { [] } 
  | ListGuard Guard { flip (:) $1 $2 }


ListLocal :: { [Local] }
ListLocal : {- empty -} { [] } 
  | ListLocal Local { flip (:) $1 $2 }


ListExp :: { [Exp] }
ListExp : Exp { (:[]) $1 } 
  | Exp ',' ListExp { (:) $1 $3 }


ListDef :: { [Def] }
ListDef : Def { (:[]) $1 } 
  | Def ',' ListDef { (:) $1 $3 }


ListLit :: { [Lit] }
ListLit : {- empty -} { [] } 
  | Lit { (:[]) $1 }
  | Lit '|' ListLit { (:) $1 $3 }


ListPcl :: { [Pcl] }
ListPcl : {- empty -} { [] } 
  | Pcl { (:[]) $1 }
  | Pcl '
' ListPcl { (:) $1 $3 }


ListId :: { [Id] }
ListId : {- empty -} { [] } 
  | Id { (:[]) $1 }
  | Id ',' ListId { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ if null ts then [] else (" before " ++ unwords (map prToken (take 4 ts)))

myLexer = tokens
}

